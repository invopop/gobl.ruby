# frozen_string_literal: true

# Amount handler. This file is *NOT* autogenerated!

module GOBL
  module Num
    # Quantity with optional decimal places that determine accuracy.
    class Amount
      # the integer value of the amount
      attr_reader :value

      # exponent, or number of significant figures
      attr_reader :exp

      def initialize(data)
        if data.is_a?(String)
          parse(data)
        elsif data.is_a?(Hash)
          @value = data[:value]
          @exp = data[:exp] || 0
        elsif data.is_a?(self.class)
          @value = data.value
          @exp = data.exp
        elsif data.respond_to?(:to_s)
          parse(data.to_s)
        else
          raise 'Unsupported input amount'
        end
      end

      def self.from_gobl!(data)
        new(data)
      end

      def self.from_json!(json)
        from_gobl!(JSON.parse(json))
      end

      def to_gobl
        to_s
      end

      def to_json(options = nil)
        JSON.generate(to_gobl, options)
      end

      def to_s
        as_s
      end

      def as_s
        return value.to_s if exp == 0
        raise 'exponent too high' if exp > 100

        p = 10**exp
        v1 = value / p
        v2 = value - (v1 * p)
        v2 = -v2 if v2 < 0
        format('%d.%0*d', v1, exp, v2)
      end

      # rescale_pair ensures both values have a matching exponential
      def self.rescale_pair(a1, a2)
        exp = a1.exp
        exp = a2.exp if a2.exp > exp
        [a1.rescale(exp), a2.rescale(exp)]
      end

      def compare(other)
        a1, a2 = self.class.rescale_pair(self, other)
        if a1.value < a2.value
          -1
        elsif a1.value > a2.value
          1
        else
          0 # same
        end
      end

      def ==(other)
        compare(other) == 0
      end

      # Multiply or divide the amount's value to match the provided
      # expontential. A lower exponential implies loosing accuracy.
      def rescale(e)
        if exp > e
          # divide
          x = exp - e
          v = (value.to_f / (10**x)).round
          self.class.new(value: v, exp: e)
        elsif exp < e
          # multiply
          x = e - exp
          v = value * (10**x)
          self.class.new(value: v, exp: e)
        else
          # nothing
          self
        end
      end

      def zero?
        value == 0
      end

      def add(a2)
        a2 = a2.rescale(exp)
        self.class.new(value: value + a2.value, exp: exp)
      end

      def subtract(a2)
        a2 = a2.rescale(exp)
        self.class.new(value: value - a2.value, exp: exp)
      end

      def multiply(a2)
        v = (value * a2.value) / (10**a2.exp)
        self.class.new(value: v, exp: exp)
      end

      def divide(a2)
        v = (value.to_f * (10**a2.exp)) / a2.value.to_f
        self.class.new(value: v.round, exp: exp)
      end

      # split the amount into equal 'x' parts providing a second
      # amount with the remainder. This is like the divide method,
      # but will correctly account for rounding errors.
      def split(x)
        a2 = divide(self.class.new(value: x, exp: 0))
        a3 = a2.multiply(self.class.new(value: x - 1, exp: 0))
        a3 = subtract(a3)
        [a2, a3]
      end

      def invert
        self.class.new(value: -value, exp: exp)
      end

      protected

      # Extract the value and exponent from the string.
      # Implementation copied from base GOBL library.
      def parse(str)
        x = str.split('.')
        raise "invalid amount '#{str}'" if x.length > 2 # abort

        v = x[0].to_i
        e = 0

        if x[1]
          v2 = x[1].to_i
          e = x[1].length
          v *= 10**e
          v += v2
        end

        @value = v
        @exp = e
      end
    end
  end
end
